<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[白酒青啤安慕希]]></title>
    <url>%2F2019%2F03%2F29%2FObject-defineProperty%2F</url>
    <content type="text"><![CDATA[从Object.defindeProperty与Proxy出发。。。 前言最近在看一些关于vue3.0的文章，其中提及到vue3.0将使用ES6的Proxy作为其观察者机制，取代之前使用的Object.defineProperty。我们都知道vue实现双向绑定是基于数据劫持从而监听数据变化来响应渲染函数实现dom更新。那么问题来了。为什么要取代呢？他们之前的优劣在哪？分别是怎么实现的数据劫持？他们的具体实现过程（原理）是什么样的？ 什么是数据劫持一般来说就是劫持对象的访问器，在属性值发生变化时我们可以获取变化。或者说通过Object.defineProperty来重写get，set函数。废话有点多，直接上代码。。。 12345678910111213const data = &#123; name:&apos;fuquanmeng&apos;&#125;Object.defineProperty(data,&apos;name&apos;,&#123; set : function(newVal) &#123; console.log(`我修改了变成了$&#123;newVal&#125;`) &#125;, get : function() &#123; return &apos;hello word&apos; &#125;&#125;)data.name = &apos;lili&apos; //触发set =&gt; 我修改了变成了liliconsole.log(data.name)//触发get =&gt; hello word 数据劫持的优势数据劫持的目前应用就在双向绑定上，而双向绑定简单来说无非就是数据变化更新视图，视图变化更新数据。视图变化可以通过事件监听得到，比如input标签就监听input上的事件就行了。重点就是在数据变化更新视图。所以数据劫持的优势就体现了： 可精确得知变化数据。我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容newVal。 无需显示调用。例如Vue运用数据劫持+发布订阅,直接可以通知变化后调用渲染函数来驱动视图。 基于Object.defineProperty数据劫持的双向绑定极简版的双向绑定1234567891011121314&lt;input id=&quot;input&quot;&gt;&lt;/input&gt; &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;const obj = &#123;&#125;Object.defineProperty(obj,&apos;key&apos;,&#123; set : function(newVal) &#123; document.getElementById(&apos;span&apos;).innerHTML = newVal; &#125;&#125;)document.getElementById(&apos;input&apos;).addEventListener(&apos;keyup&apos;, function(e)&#123; obj.key = e.target.value;&#125;) 但是这个双向绑定貌似问题很多首先这代码耦合性太高数据，方法，dom都连接在一起，而且只能监听对象的一个属性。所以我们要膜拜一下尤大大vue的发布订阅模式来实现。。 发布订阅模式的实现的双向绑定 首先我们要监听所有属性所以要实现一个监听器Observer用来监听所有属性，如果属性变化了就要通知订阅者Watcher看是否需要更新。因为每一个订阅者绑定一个更新函数，所以我们要实现一个订阅器Dep来收集这些订阅者，来负责储存订阅者和消息的分发。所以我们实现的就是： 监听器Observer =&gt; 用来劫持并监听所有属性，如果有变动的，就通知订阅者。 订阅者Watcher =&gt; 收到属性的变化并执行相应函数来更新视图。 订阅器Dep =&gt; 收集所有订阅者,负责消息的分发执行notify。 实现监听器Observer 核心方法就是Object.defineProperty()。因为要遍历所有属性（包括子属性），所以要通过递归来遍历监听所有值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function defineReactive(targetObj,key,val)&#123; //监听的具体方法 observer(val) //递归遍历子属性的值 如果是复杂类型则继续遍历监听 Object.defineProperty(targetObj,key,&#123; enumerable: true, configurable: true, set: function(newVal)&#123; if (val === newVal) return; val = newVal observer(newVal) // 用来监测赋的新值 console.log(`我监听到了$&#123;key&#125;发生变化`) &#125;, get :function()&#123; return val &#125; &#125;)&#125;function observer(targetObj)&#123; //总方法 监听目标对象 if(!targetObj || typeof targetObj != &apos;object&apos;) return ; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 return new Observer(targetObj);&#125;class Observer &#123; //监听者 constructor(targetObj) &#123; this.targetObj = targetObj; this.walk(targetObj); //遍历目标对象并监听 &#125; walk(targetObj)&#123; //遍历目标对象并监听 Object.keys(targetObj).forEach(key =&gt; &#123; defineReactive(targetObj, key, targetObj[key]); //监听的具体方法 &#125;) &#125;&#125;var obj = &#123; name : &#123; a : &apos;&apos; &#125;, job : &apos;js&apos;&#125;observer(obj)obj.name.a = &apos;blabla&apos; //我监听到了a发生变化obj.job = &apos;play&apos; //我监听到了job发生变化 实现订阅器Dep 维护一个数组，用来收集订阅者，数据变化触发notify，再调用订阅者的update方法。 12345678910111213function Dep() &#123; //订阅器构造函数 this.subs = []; //存储订阅器的数组&#125;Dep.prototype = &#123; addSub : function(sub) &#123; //添加订阅者Watcher的方法 this.subs.push(sub) &#125;, notify : function() &#123; //数据变化后通知所有的订阅者Watcher =&gt; 所以在监听器里的set方法里加入Dep.notify来通知订阅者Watcher数据变化了 this.subs.forEach(sub =&gt; &#123; sub.update() //触发订阅者Watcher相应的渲染方法 &#125;) &#125;&#125; 我们知道在初始化vue实例的时候监听器Observer要监听实例的data的所有属性，而每一个属性都要关联一个订阅者Watcher来根据属性的变化来执行相应的函数。而我们的订阅器Dep就是专门来收集订阅者并通知触发各个订阅者的函数。那么问题来了，如何在vue实例化的时候就把订阅者添加到订阅器呢？带着这个疑问我们看一下订阅者Watcher 实现订阅者Watcher12345678910111213141516171819202122232425function Watcher(vm,exp,cb) &#123; this.vm = vm; //当前vue实例 this.exp = exp; //订阅当前vue实例的属性 this.cb = cb; //数据更新的回调函数 this.value = this.get() //答案在这里：这里有两个作用1.可以保留更新之前的旧值。2.将自己添加到订阅器！！&#125;Watcher.propotype = &#123; get : function() &#123; Dep.target = this;//把自己（订阅者Watcher）赋值给Dep.target var value = this.vm.data[exp];//这个操作就是获取实例上data属性的值 =&gt; 也就是触发了监听（Object.defineProperty）里的get方法 =&gt; 所以我们可以利用这个方法来向dep添加Watcher（也就是Dep.target） Dep.target = null;//释放自己 用于下一个Watcher使用 return value //获取实例上的值 &#125;, update : function() &#123; //对外暴露接口，当数据更新时候，可以通过Dep.notify通知然后触发update来调用 this.run() &#125;, run : function() &#123; var newValue = this.get();//数据更新之后获取的value var oldValue = this.value;// 保留的更新之前的value if(newValue != oldValue)&#123; this.value = newValue //更新旧值 this.cb.call(this.vm,newValue,oldValue) //数据更新后的回调函数 &#125; &#125;&#125; 所以Dep.target就是连接订阅器Dep和订阅者Watcher的桥梁，并且利用订阅者Watcher实例化的时候触发get方法从而强制触发监听（Object.defineProperty）里的get方法来把自己Watcher添加到订阅器Dep中;所以上面的监听器Observer要做一些修改。 12345678910111213141516171819202122232425262728293031323334353637383940function defineReactive(targetObj,key,val)&#123; //监听的具体方法 observer(val) //递归遍历子属性的值 如果是复杂类型则继续遍历监听 var dep = new Dep(); //实例化订阅器来存储订阅者 Object.defineProperty(targetObj,key,&#123; enumerable: true, configurable: true, set: function(newVal)&#123; if (val === newVal) return; val = newVal observer(newVal) // 用来监测赋的新值 dep.notify();//通知所有订阅者，数据改变了 console.log(`我监听到了$&#123;key&#125;发生变化`) &#125;, get :function()&#123; //触发向订阅器添加订阅者的方法 if(Dep.target)&#123;//由上而知Dep.target指向了一个订阅者Watcher，如果有则向订阅器添加 Dep.addSub(Dep.target) //订阅器添加订阅者方法 &#125; return val &#125; &#125;)&#125;function observer(targetObj)&#123; //总方法 监听目标对象 if(!targetObj || typeof targetObj != &apos;object&apos;) return ; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 return new Observer(targetObj);&#125;class Observer &#123; //监听者 constructor(targetObj) &#123; this.targetObj = targetObj; this.walk(targetObj); //遍历目标对象并监听 &#125; walk(targetObj)&#123; //遍历目标对象并监听 Object.keys(targetObj).forEach(key =&gt; &#123; defineReactive(targetObj, key, targetObj[key]); //监听的具体方法 &#125;) &#125;&#125;Dep.target = null; //初始化订阅器与订阅者之间的桥梁 到这就可以实现一个简单的从数据响应到dom的绑定了，虽然编译器compile没做，不过不在这篇文章的讨论的范围内。当然Watcher过滤也没做不过都可以暂时忽略。。。 现在我们通过一个简单例子把Observer和Watcher关联起来。 12345678910111213141516171819&lt;h1 id=&quot;name&quot;&gt;name&lt;/h1&gt;&lt;button id=&quot;change&quot;&gt;改变&lt;/button&gt;var element = document.querySelector(&apos;#name&apos;);var myVue = new _myVue(&#123;&apos;name&apos;:&apos;fuquanmeng&apos;&#125;,element,&apos;name&apos;) // 初始化document.querySelector(&apos;#change&apos;).addEventListener(&apos;onClick&apos;, function(e)&#123; _myVue.data.name = &apos;lili&apos;&#125;)function _myVue (data, el, exp) &#123; this.data = data; //目标对象 observer(data); //监听目标对象 el.innerHTML = this.data[exp]; // 初始化dom模板里的数据 new Watcher(this, exp, function (value) &#123; //目标对象变化后的回调 el.innerHTML = value; &#125;); return this;&#125; 到这已经完全实现了基于Object.defineProperty来实现的数据响应到dom的绑定了。Proxy相对于Object.defineProperty来实现数据劫持的优势： 从上面的实现中可以看到Object.defineProperty的数据劫持是要对各个对象的每个属性都要遍历(Object.keys(targetObj).forEach(key =&gt; { defineReactive(targetObj, key, targetObj[key]); //监听的具体方法 }))，如果属性值也是对象那么需要递归遍历,显然能劫持一个完整的对象是更好的选择。所以Proxy就来了，Proxy可以理解为他在目标对象外层设了一个拦截，外界对目标对象访问时都要通过这层拦截，因此可以对外界的访问进行过滤和改写，也就是所说的数据劫持。所以他的优势就很好体现了。不用递归遍历从而省性能。 如果把上面的{‘name’:’fuquanmeng’}改成{‘name’:[]}然后再onclick函数里写_myVue.data.name.push(111)。显然监听不到了。。。所以Object.defineProperty无法监听数组变化，虽然Vue已经把数组的这些方法[‘push’, ‘pop’, ‘shift’, ‘unshift’, ‘splice’, ‘sort’, ‘reverse’]hack掉了但是其他的数组的属性依旧还是检测不到。而Proxy可以直接监听数组的变化。 还是极简版的双向绑定我们用proxy来改写 基于Proxy的极简双向绑定 123456789101112131415161718192021222324&lt;input id=&quot;input&quot;&gt;&lt;/input&gt; &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;const input = document.getElementById(&apos;input&apos;)const span = document.getElementById(&apos;span&apos;)const obj = &#123;&#125;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === &apos;text&apos;) &#123; span.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);input.addEventListener(&apos;keyup&apos;, function(e) &#123; newObj.text = e.target.value;&#125;); 监听数组变化就直接const obj = []也是可以监听得到，在这就不列举了。 总结 优势：Proxy相对于Object.defineProperty的优点在于可以检测数组的变化而且不用对目标对象的各个属性遍历监听，而且Proxy返回的是新对象我们可以只操作新对象来达到目的。 劣势：Proxy的劣势就是兼容性问题,而且无法用polyfill来磨平各个浏览器的差异。。。。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假如我年少有为不自卑，懂得什么是珍贵]]></title>
    <url>%2F2019%2F03%2F21%2Ff-note%2F</url>
    <content type="text"><![CDATA[“XX,点名的时候帮我答个到~ 我不后悔 A:后悔上大学吗？ 我:不后悔。 A:收获到了什么？ 我：想听吗？给我一碗酒。。。 “你有东西落下了” “什么” “你的青春 三个人的外联部 晚自习上的肉夹馍与1Q84 图书馆最后一把的中等人机 风筝广场上的嘻哈舞 早上六点钟的春泥 六号公寓下的表白 运动会上的小桥 3140那一晚的烧烤 说走就走的泰山行 北门的麻辣香锅 小院的炒饭与柠檬汁 歌儿里那几瓶最凉的啤酒 每晚凌晨的汽水与卷饼 弘德书院的淘宝店 公寓关不上的窗户与摄像头 青岛啤酒节的那束花 上海电音节的那两个夜晚 寿光科技学院的那几个二维码 金宝路上的那场雪 青岛方特的那几碗酒 下午六点的篮球场 东明到新庄的那两个人 还有meme米开朗的石头人，不败小小的狗头人，雄鹰联一把的死歌，武陵诸神的武器，zhi怕XB队友的狗熊征战过的召唤师峡谷。可惜不知道下次在一块征战是什么时候了。。。 每一个标签都是一段美好的回忆。我想一晚上我都讲不完，只是现在每一次回潍坊我都会去坐一次56路。。。 可能北门小摊已经关门了，可能校园广播还没放，可能图书馆坐满了，可能篮球场已经没场了，可能三号公寓已经不让我进了，但是在听到潍坊学院北门到了那一刹那后我还是会奋不顾身下车。。。 明天，你好。再见，昨天 大学的时候曾对不起一个女生，甚至连毕业的时候也没有好好和她说几句道别的话。。。 说不成熟不懂事都是借口，还是怪自己没有珍惜感情。当然在毕业后的几个月里，我在另一个她哪里也得到了刻骨铭心的伤痛。有时候一想或许这就是报应吧。。。 “长大”其实有时候也挺快的，对吧。 微风过，树微动。叶叶只为花相守愿只求，胭脂留。有你在左我在右说太多，没有用。有缘会长相守]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Memory</tag>
        <tag>College</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法相拥的人要好好道别]]></title>
    <url>%2F2019%2F03%2F15%2Fbeginning%2F</url>
    <content type="text"><![CDATA[种一棵树最好的时间是十年前，其次是现在。自己的第一篇日记就从这里开始吧。。。 总是要留下点什么 有时候也会想自己是要奔三的人了，回首发现好像也没剩下什么。 搭建这个博客的目的当然除了自己的矫情之外还有一些学习和工作上的总结，毕竟对于”忘”这个人体属性而言，我觉得他已经遍满了我人生中的各个角落。。。 前几篇文章我就想回顾一下自己大学以及大学后的生活把，发发牢骚。毕竟钢铁直男能憋出几个字来也是实属不易。 每个人都有他自己的节奏，你要按照自己的来 记得去年看过一篇文章《每个人都有自己节奏》其中有说道：随着年龄增长，有的人已经成家立业，甚至有了小孩，生活逐渐稳定下来，有的人毕业了还没有找到工作，有的人身处一段感情，却发现自己另有所爱。。。 上个月过年回家，和往常一样谈到了感情的事，看到父母逐渐变老的脸庞，有时候也会质疑自己是不是要稳定下来，多陪陪父母，该有一个家了。。。 有时候确实挺恨自己没出息，到了大部分人该有的年纪的时候却没有他们的该有的东西。但总归还是要面对现实，无论现在是顺境还是迷茫，要相信在命运给你安排的节奏里，一切都准时。。 主动点，温柔点，努力点 不知道是因为什么，做什么事情都没有像以前一样的兴趣和斗志。更加很少主动去和别人交流，或许是怕打扰别人把，甚至对于喜欢的人也是变得越来越主动疏远。这恐怕是自闭了。。。我要改！！！ 越来越发现自己的脾气好像确实没有以前好了，有时候会一点事就忍不住发火。然后过了一小会，就会很后悔。以前我可是脾气好的爆的人阿。我也不知道为什么会这样，可能是最近压力有点大加上休息不好吧，打算入夏的时候就多去运动运动，应该还有救。。 发现人确实不能一直再一个环境待太久，比如现在我的工作，虽然一周的工作量对于我来说一上午或许就能完成。但是剩余的时间却没有好好利用来扩展自己的知识领域，一想还是挺后悔的，希望今年能换份工作，无论 北京，上海，还是青岛。重要的是不要再愧对于自己把。。。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
</search>
