<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我说今晚月光那么美,你说是的]]></title>
    <url>%2Flist-select.html</url>
    <content type="text"><![CDATA[记录一次反人类的爬坑之路。。 前言盼望着，盼望着，老大来了，需求的脚步近了。。。 在我接触的前端表格中（例：邮箱）分页全选是有的，而且操作都是在当前页操作（比如全选当前分页的list然后删除），且切换分页的时候上一分页选中的数据则不保留。但是，我们做的这个分页那就不一样了，既要能全部分 页都要一键全选而且点击别的分页还要保留之前一页选中的list并且返回点击还要恢复选中的样式（分页单独查询）。wtf？？？？ 开始听到这话的五分钟里，脑海中浮现了一个删库跑路的念头，然后离职就可以尽情嗨皮，岂不美滋滋。 emmmmm 回头看了看钱包一秒回到现实。。。 静下心来，仔细一想。写一个缓存数据的id数组，然后每次分页查询的时候对比这个数组，如果返回的数据能和这个id数组匹配到的话就绑定样式。至于全选，模拟一下分页的请求然后全部填到id数组。。。 好像给我十分钟我也能搞定的样子。然后事实并没有那么简单。。。 初步入坑因为用的elementUI框架，所以有自带的触发选择的回调事件，并且变化后选择的数据都给你返回了： 123select(data)&#123; this.selection = data;&#125;, 对于对比是否选中了某一行，elementUI也给你集成了切换选中状态的事件： 1this.$refs.some-ref.toggleRowSelection(row,true); //模拟选中 不过切换选中状态的时候要配合this.$nextTick使用，别问我怎么知道的看这部分的小标题。。 写到这里感觉已经万事具备了。 正式入坑首先准备一个id数组在这里就叫articlelist_selectIdArr然后每次选中状态变化时把idpush到里面: 1234select(data)&#123; this.articlelist_selectIdArr = []; //初始化数组 data.forEach(item =&gt; this.articlelist_selectIdArr.push(item.id)) &#125;, 然后再切换分页的时候toggleRowSelection 12345pageChange()&#123; .... //分页查询的数据业务处理 this.$nextTick(() =&gt; this.$refs.some-ref.toggleRowSelection(row,true)) ...&#125;, 满怀信心测试一波然后。。问题来了 发现选中添加后然后分页切换回来之前分页的数据则没有保留。 找了一下原因是因为toggleRowSelection的时候还会触发切换选中状态的事件也就是又初始化id数组了所以数组永远空值。 然后就改一下select： 12345select(data)&#123; //this.articlelist_selectIdArr = []; //初始化数组 data.forEach(item =&gt; this.articlelist_selectIdArr.push(item.id)) this.articlelist_selectIdArr = [...this.articlelist_selectIdArr] //去重&#125;, 这次发现分页切换回来数据已经保留了，但是新问题来了，你取消选择的时候id数组其实并没有执行删除操作而是在之前的基础上又加了这次选择变化后的数据。所以我脑子一抽又想到了个办法就是在点击checkbox添加一个flag并且同时改变flag状态为false此时就可以再重新初始化数组，如果点击分页查询操作的时候再设为true这样就保留之前的id数组： 1234567891011select(data)&#123; if(!this.flag) this.articlelist_selectIdArr = []; //初始化数组 data.forEach(item =&gt; this.articlelist_selectIdArr.push(item.id)) &#125;,pageChange()&#123; .... //分页查询的数据业务处理 this.flag = true; this.$nextTick(() =&gt; this.$refs.some-ref.toggleRowSelection(row,true)) ...&#125;, 这次确实能保证返回分页数据保留并且取消选中时能重新响应“当前页面选中的id”，但是！！！！！ 响应的只是当前页面的选中数据，因为select函数的data只是当前页面的选中数据，也就意味着如果你全选了1,2,3页的数据然后再第一页取消全选的时候，也就是flag为false的时候你已经又把数组初始化了也就是意味着二三页的数据又没了。。。。 现在只能用两个字来形容我现在的思路—————-“僵硬” 重整思路在前面尝试的几种方案后发现确实有的问题还cover不到。重新理了一下，觉得是我的维护数组的方式有问题，不能准确的响应到那一个id选择状态发生了变化（因为select返回的总是选择变化后的数据）;所以我要准确的找到数组的哪一项发生了变化，也就是监听select的data，查看是否增加选中、是否取消选中、是否切换页面操作、是否当前页面的操作。然后再分别对应数组的增删： select(data){ this.selectDATA = data; //绑定监听 } pageChange(){ //无变化 .... //分页查询的数据业务处理 this.flag = true; this.$nextTick(() =&gt; this.$refs.some-ref.toggleRowSelection(row,true)) ... } //监听变化 watch:{ selectDATA:{ handler(newVal,oldVal){ if(this.flag) return //判断是不是切换分页操作 切换分页对id数组无影响， 只是依赖id数组来切换选中行而已 let newIdArr = [],oldIdArr = []; newVal.forEach(i =&gt; newIdArr.push(i.id))//新的数组id oldVal.forEach(i =&gt; oldIdArr.push(i.id))//旧的数组id if(newVal.length &gt; oldVal.length){ //此时是选中操作 let result = newIdArr.filter(i =&gt; !new Set(oldIdArr).has(i))// newIdArr减oldIdArr的差集 this.articlelist_selectIdArr.push(...result) //维护数组 }; if(newVal.length &lt; oldVal.length){ //此时是取消选中操作 let result = oldIdArr.filter(i =&gt; !new Set(newIdArr).has(i))// oldIdArr减newIdArr的差集 result.forEach(i =&gt; { this.articlelist_selectIdArr = this.articlelist_selectIdArr.filter(item =&gt; item != i) //维护数组 }) } }, deep:true } } 经测试没啥问题，全选就简单了分页获取然后挨个push。搞定！ 总结想起了初中数学老师一句话：没有困难，制造困难也要上。 挖坑填坑是程序猿的必经之路，共勉。。。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想和你看看星空，只谈夜色与微风]]></title>
    <url>%2FnextTick.html</url>
    <content type="text"><![CDATA[this.$nextTick(() =&gt; ‘blablabla’)。。。 前言在之前的项目中，因为经常会用的一些可视化库。所以就不必然的会在数据接收之后操作dom。当初年少无知的我经常因为dom还未“更新”去踩坑甚至到怀疑人生。。。。虽然有些“云程序猿”给了个$(function(){})的解决方法。本着不装逼非程序猿的思维感觉还是有点小low。俗话说世间万物皆有因果，只能怪我当初太年轻没好好看文档。。。 nextTick作用是什么首先我们知道vue的dom更新是异步的。而nextTick则是利用事件循环在dom更新（异步）完毕后再执行。这样其实就解决了上面的提出的获取不到数据变化后dom的问题。 关于异步更新队列官网关于异步更新队列的说明：可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用 事件循环？也就是事件队列也就联系到了宏任务微任务也就可以联系到了setTimout等等 过滤watcher？不难想到上一篇关于双向绑定的watcher里一笔带过的watcher过滤（其实就是根据watcher的id的判断,虽然代码里也没写）。。。 带着这两个小问题我们看看vue nextTick源码的实现。 还是要看watcher背景1234567891011121314151617export default &#123; data () &#123; return &#123; msg: 0 &#125; &#125;, mounted () &#123; this.msg = 1 this.msg = 2 this.msg = 3 &#125;, watch: &#123; msg () &#123; console.log(this.msg) //只打印一次3 &#125; &#125;&#125; 首先我们知道当数据变化会触发监听器的set方法 =&gt; 触发订阅器dep的notfiy方法 =&gt; 触发订阅者watcher的update方法 =&gt; 触发this.run执行相应回调 =&gt; 然后依次打印1，2,3。为什么现在却只打印一个3？ qunueWatcher的update 实际上watcher的update方法：1234567891011this.deep = this.user = this.lazy = this.sync = false... update () &#123; if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() //同步。。。 &#125; else &#123; queueWatcher(this) //异步推送到观察者队列中，即异步更新调用这个方法。 &#125; &#125; 我们发现其实update做的只是异步推送到观察者队列（缓存了msg的改变，异步调用时直接取到最后的值）。我们再看queueWatcher这个方法： queueWatcher12345678910111213141516171819202122export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; //这一块其实就是过滤id。当观察者队列已经有该观察者的id则跳过。 has[id] = true if (!flushing) &#123; queue.push(watcher) &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush if (!waiting) &#123; //waiting作用保证回调函数flushSchedulerQueue只允许放入callbacks一次，并且再下一个tick时，Watch对象才会被遍历取出，更新视图。 waiting = true nextTick(flushSchedulerQueue) //这才是执行nexttick的语句 &#125; &#125;&#125; 从上面可以看出waiting其实就是控制在下一个tick时调用异步刷新视图的标识，而控制什么时候是下一个tick就是nextTick方法，刷新视图则是flushSchedulerQueue方法。所以要看看flushSchedulerQueue和nextTick这两个方法 nextTick(flushSchedulerQueue)flushSchedulerQueue flushSchedulerQueue方法 其实就是实际执行的watch的run来更新视图123456789101112function flushSchedulerQueue () &#123; flushing = true let watcher, id ... for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] id = watcher.id has[id] = null watcher.run() //执行的watch视图更新 ... &#125;&#125; nextTick 重点则是nexttick方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293export const nextTick = (function () &#123; const callbacks = [] //存储回调函数 let pending = false // 一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送 let timerFunc //何时调用回调函数的标识位 function nextTickHandler () &#123; //调用回调函数的方法 pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() ///触发callback的回调函数 &#125; &#125; // An asynchronous deferring mechanism. // In pre 2.4, we used to use microtasks (Promise/MutationObserver) // but microtasks actually has too high a priority and fires in between // supposedly sequential events (e.g. #4521, #6690) or even between // bubbling of the same event (#6566). Technically setImmediate should be // the ideal choice, but it&apos;s not available everywhere; and the only polyfill // that consistently queues the callback after all DOM events triggered in the // same loop is by using MessageChannel. 总结就是：改了多次最终nextTick采取的策略是默认走microTask（虽然在dom事件中还有问题）。 /* istanbul ignore if */ if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123; //优先用promise来实现 const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn&apos;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&apos;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true &#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; ( //其次是html5的MutationObserver isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos; )) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true &#125; else if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123; //其其次就是setImmediate // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125; &#125; else &#123; //最后没办法用settimeout // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;export function nextTick (cb?: Function, ctx?: Object) &#123; //真正调用的nextTick函数 let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &apos;nextTick&apos;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; //用于判断是否有队列正在执行回调 pending = true //如果在执行回调中那么就要在下一个tick时调用 timerFunc() //执行回调 &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125;&#125;)() 所以nextTick方法其实就是看timerfunc方法何时调用而timerfunc则要根据事件循环的定义顺序，在vue中定义的顺序是优先microtask然后macrotask。microtask最佳选择是Promise其次是MutationObserver（h5新增的特性在ios上有些不兼容），macrotask最佳方案是setImmediate（仅仅在ie和nodeJs环境支持）其次也就是setTimeout了（虽然有4ms延迟）。 microtask与macrotask执行顺序排序 当一个程序有：setTimeout（macro）， setInterval（macro） ，setImmediate（macro）， I/O（macro）， UI渲染（macro），Promise（micr0） ，process.nextTick（micr0）， Object.observe（micr0）， MutationObserver（micr0）的时候执行顺序是： 123宏：I/O =&gt; UI渲染微：process.nextTick =&gt; Promise =&gt; MutationObserver =&gt; Object.observe(废弃) 新的循环 宏：setImmediate =&gt; setTimeout,setInterval 总结： nextTick作用：保证了更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用（拿到了更新后的dom），缓存了数据变化以及过滤了watcher队列从而大大优化了性能 nextTick原理：用异步队列的方式来控制DOM更新和nextTick回调先后执行。microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕。因为兼容性问题，vue不得不做了microtask向macrotask的降级方案。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白酒青啤安慕希]]></title>
    <url>%2FObject-defineProperty.html</url>
    <content type="text"><![CDATA[从Object.defindeProperty与Proxy出发。。。 前言最近在看一些关于vue3.0的文章，其中提及到vue3.0将使用ES6的Proxy作为其观察者机制，取代之前使用的Object.defineProperty。我们都知道vue实现双向绑定是基于数据劫持从而监听数据变化来响应渲染函数实现dom更新。那么问题来了。为什么要取代呢？他们之前的优劣在哪？分别是怎么实现的数据劫持？他们的具体实现过程（原理）是什么样的？ 什么是数据劫持一般来说就是劫持对象的访问器，在属性值发生变化时我们可以获取变化。或者说通过Object.defineProperty来重写get，set函数。废话有点多，直接上代码。。。 12345678910111213const data = &#123; name:&apos;fuquanmeng&apos;&#125;Object.defineProperty(data,&apos;name&apos;,&#123; set : function(newVal) &#123; console.log(`我修改了变成了$&#123;newVal&#125;`) &#125;, get : function() &#123; return &apos;hello word&apos; &#125;&#125;)data.name = &apos;lili&apos; //触发set =&gt; 我修改了变成了liliconsole.log(data.name)//触发get =&gt; hello word 数据劫持的优势数据劫持的目前应用就在双向绑定上，而双向绑定简单来说无非就是数据变化更新视图，视图变化更新数据。视图变化可以通过事件监听得到，比如input标签就监听input上的事件就行了。重点就是在数据变化更新视图。所以数据劫持的优势就体现了： 可精确得知变化数据。我们劫持了属性的setter,当属性值改变,我们可以精确获知变化的内容newVal。 无需显示调用。例如Vue运用数据劫持+发布订阅,直接可以通知变化后调用渲染函数来驱动视图。 基于Object.defineProperty数据劫持的双向绑定极简版的双向绑定1234567891011121314&lt;input id=&quot;input&quot;&gt;&lt;/input&gt; &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;const obj = &#123;&#125;Object.defineProperty(obj,&apos;key&apos;,&#123; set : function(newVal) &#123; document.getElementById(&apos;span&apos;).innerHTML = newVal; &#125;&#125;)document.getElementById(&apos;input&apos;).addEventListener(&apos;keyup&apos;, function(e)&#123; obj.key = e.target.value;&#125;) 但是这个双向绑定貌似问题很多首先这代码耦合性太高数据，方法，dom都连接在一起，而且只能监听对象的一个属性。所以我们要膜拜一下尤大大vue的发布订阅模式来实现。。 发布订阅模式的实现的双向绑定 首先我们要监听所有属性所以要实现一个监听器Observer用来监听所有属性，如果属性变化了就要通知订阅者Watcher看是否需要更新。因为每一个订阅者绑定一个更新函数，所以我们要实现一个订阅器Dep来收集这些订阅者，来负责储存订阅者和消息的分发。所以我们实现的就是： 监听器Observer =&gt; 用来劫持并监听所有属性，如果有变动的，就通知订阅者。 订阅者Watcher =&gt; 收到属性的变化并执行相应函数来更新视图。 订阅器Dep =&gt; 收集所有订阅者,负责消息的分发执行notify。 实现监听器Observer 核心方法就是Object.defineProperty()。因为要遍历所有属性（包括子属性），所以要通过递归来遍历监听所有值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function defineReactive(targetObj,key,val)&#123; //监听的具体方法 observer(val) //递归遍历子属性的值 如果是复杂类型则继续遍历监听 Object.defineProperty(targetObj,key,&#123; enumerable: true, configurable: true, set: function(newVal)&#123; if (val === newVal) return; val = newVal observer(newVal) // 用来监测赋的新值 console.log(`我监听到了$&#123;key&#125;发生变化`) &#125;, get :function()&#123; return val &#125; &#125;)&#125;function observer(targetObj)&#123; //总方法 监听目标对象 if(!targetObj || typeof targetObj != &apos;object&apos;) return ; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 return new Observer(targetObj);&#125;class Observer &#123; //监听者 constructor(targetObj) &#123; this.targetObj = targetObj; this.walk(targetObj); //遍历目标对象并监听 &#125; walk(targetObj)&#123; //遍历目标对象并监听 Object.keys(targetObj).forEach(key =&gt; &#123; defineReactive(targetObj, key, targetObj[key]); //监听的具体方法 &#125;) &#125;&#125;var obj = &#123; name : &#123; a : &apos;&apos; &#125;, job : &apos;js&apos;&#125;observer(obj)obj.name.a = &apos;blabla&apos; //我监听到了a发生变化obj.job = &apos;play&apos; //我监听到了job发生变化 实现订阅器Dep 维护一个数组，用来收集订阅者，数据变化触发notify，再调用订阅者的update方法。 12345678910111213function Dep() &#123; //订阅器构造函数 this.subs = []; //存储订阅器的数组&#125;Dep.prototype = &#123; addSub : function(sub) &#123; //添加订阅者Watcher的方法 this.subs.push(sub) &#125;, notify : function() &#123; //数据变化后通知所有的订阅者Watcher =&gt; 所以在监听器里的set方法里加入Dep.notify来通知订阅者Watcher数据变化了 this.subs.forEach(sub =&gt; &#123; sub.update() //触发订阅者Watcher相应的渲染方法 &#125;) &#125;&#125; 我们知道在初始化vue实例的时候监听器Observer要监听实例的data的所有属性，而每一个属性都要关联一个订阅者Watcher来根据属性的变化来执行相应的函数。而我们的订阅器Dep就是专门来收集订阅者并通知触发各个订阅者的函数。那么问题来了，如何在vue实例化的时候就把订阅者添加到订阅器呢？带着这个疑问我们看一下订阅者Watcher 实现订阅者Watcher12345678910111213141516171819202122232425function Watcher(vm,exp,cb) &#123; this.vm = vm; //当前vue实例 this.exp = exp; //订阅当前vue实例的属性 this.cb = cb; //数据更新的回调函数 this.value = this.get() //答案在这里：这里有两个作用1.可以保留更新之前的旧值。2.将自己添加到订阅器！！&#125;Watcher.propotype = &#123; get : function() &#123; Dep.target = this;//把自己（订阅者Watcher）赋值给Dep.target var value = this.vm.data[exp];//这个操作就是获取实例上data属性的值 =&gt; 也就是触发了监听（Object.defineProperty）里的get方法 =&gt; 所以我们可以利用这个方法来向dep添加Watcher（也就是Dep.target） Dep.target = null;//释放自己 用于下一个Watcher使用 return value //获取实例上的值 &#125;, update : function() &#123; //对外暴露接口，当数据更新时候，可以通过Dep.notify通知然后触发update来调用 this.run() &#125;, run : function() &#123; var newValue = this.get();//数据更新之后获取的value var oldValue = this.value;// 保留的更新之前的value if(newValue != oldValue)&#123; this.value = newValue //更新旧值 this.cb.call(this.vm,newValue,oldValue) //数据更新后的回调函数 &#125; &#125;&#125; 所以Dep.target就是连接订阅器Dep和订阅者Watcher的桥梁，并且利用订阅者Watcher实例化的时候触发get方法从而强制触发监听（Object.defineProperty）里的get方法来把自己Watcher添加到订阅器Dep中;所以上面的监听器Observer要做一些修改。 12345678910111213141516171819202122232425262728293031323334353637383940function defineReactive(targetObj,key,val)&#123; //监听的具体方法 observer(val) //递归遍历子属性的值 如果是复杂类型则继续遍历监听 var dep = new Dep(); //实例化订阅器来存储订阅者 Object.defineProperty(targetObj,key,&#123; enumerable: true, configurable: true, set: function(newVal)&#123; if (val === newVal) return; val = newVal observer(newVal) // 用来监测赋的新值 dep.notify();//通知所有订阅者，数据改变了 console.log(`我监听到了$&#123;key&#125;发生变化`) &#125;, get :function()&#123; //触发向订阅器添加订阅者的方法 if(Dep.target)&#123;//由上而知Dep.target指向了一个订阅者Watcher，如果有则向订阅器添加 Dep.addSub(Dep.target) //订阅器添加订阅者方法 &#125; return val &#125; &#125;)&#125;function observer(targetObj)&#123; //总方法 监听目标对象 if(!targetObj || typeof targetObj != &apos;object&apos;) return ; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 return new Observer(targetObj);&#125;class Observer &#123; //监听者 constructor(targetObj) &#123; this.targetObj = targetObj; this.walk(targetObj); //遍历目标对象并监听 &#125; walk(targetObj)&#123; //遍历目标对象并监听 Object.keys(targetObj).forEach(key =&gt; &#123; defineReactive(targetObj, key, targetObj[key]); //监听的具体方法 &#125;) &#125;&#125;Dep.target = null; //初始化订阅器与订阅者之间的桥梁 到这就可以实现一个简单的从数据响应到dom的绑定了，虽然编译器compile没做，不过不在这篇文章的讨论的范围内。当然Watcher过滤也没做不过都可以暂时忽略。。。 现在我们通过一个简单例子把Observer和Watcher关联起来。 12345678910111213141516171819&lt;h1 id=&quot;name&quot;&gt;name&lt;/h1&gt;&lt;button id=&quot;change&quot;&gt;改变&lt;/button&gt;var element = document.querySelector(&apos;#name&apos;);var myVue = new _myVue(&#123;&apos;name&apos;:&apos;fuquanmeng&apos;&#125;,element,&apos;name&apos;) // 初始化document.querySelector(&apos;#change&apos;).addEventListener(&apos;onClick&apos;, function(e)&#123; _myVue.data.name = &apos;lili&apos;&#125;)function _myVue (data, el, exp) &#123; this.data = data; //目标对象 observer(data); //监听目标对象 el.innerHTML = this.data[exp]; // 初始化dom模板里的数据 new Watcher(this, exp, function (value) &#123; //目标对象变化后的回调 el.innerHTML = value; &#125;); return this;&#125; 到这已经完全实现了基于Object.defineProperty来实现的数据响应到dom的绑定了。Proxy相对于Object.defineProperty来实现数据劫持的优势： 从上面的实现中可以看到Object.defineProperty的数据劫持是要对各个对象的每个属性都要遍历(Object.keys(targetObj).forEach(key =&gt; { defineReactive(targetObj, key, targetObj[key]); //监听的具体方法 }))，如果属性值也是对象那么需要递归遍历,显然能劫持一个完整的对象是更好的选择。所以Proxy就来了，Proxy可以理解为他在目标对象外层设了一个拦截，外界对目标对象访问时都要通过这层拦截，因此可以对外界的访问进行过滤和改写，也就是所说的数据劫持。所以他的优势就很好体现了。不用递归遍历从而省性能。 如果把上面的{‘name’:’fuquanmeng’}改成{‘name’:[]}然后再onclick函数里写_myVue.data.name.push(111)。显然监听不到了。。。所以Object.defineProperty无法监听数组变化，虽然Vue已经把数组的这些方法[‘push’, ‘pop’, ‘shift’, ‘unshift’, ‘splice’, ‘sort’, ‘reverse’]hack掉了但是其他的数组的属性依旧还是检测不到。而Proxy可以直接监听数组的变化。 还是极简版的双向绑定我们用proxy来改写 基于Proxy的极简双向绑定 123456789101112131415161718192021222324&lt;input id=&quot;input&quot;&gt;&lt;/input&gt; &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;const input = document.getElementById(&apos;input&apos;)const span = document.getElementById(&apos;span&apos;)const obj = &#123;&#125;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === &apos;text&apos;) &#123; span.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);input.addEventListener(&apos;keyup&apos;, function(e) &#123; newObj.text = e.target.value;&#125;); 监听数组变化就直接const obj = []也是可以监听得到，在这就不列举了。 总结 优势：Proxy相对于Object.defineProperty的优点在于可以检测数组的变化而且不用对目标对象的各个属性遍历监听，而且Proxy返回的是新对象我们可以只操作新对象来达到目的。 劣势：Proxy的劣势就是兼容性问题,而且无法用polyfill来磨平各个浏览器的差异。。。。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假如我年少有为不自卑，懂得什么是珍贵]]></title>
    <url>%2Ff-note.html</url>
    <content type="text"><![CDATA[“XX,点名的时候帮我答个到~ 我不后悔 A:后悔上大学吗？ 我:不后悔。 A:收获到了什么？ 我：想听吗？给我一碗酒。。。 “你有东西落下了” “什么” “你的青春 三个人的外联部 晚自习上的肉夹馍与1Q84 图书馆最后一把的中等人机 风筝广场上的嘻哈舞 早上六点钟的春泥 六号公寓下的表白 运动会上的小桥 3140那一晚的烧烤 说走就走的泰山行 北门的麻辣香锅 小院的炒饭与柠檬汁 歌儿里那几瓶最凉的啤酒 每晚凌晨的汽水与卷饼 弘德书院的淘宝店 公寓关不上的窗户与摄像头 青岛啤酒节的那束花 上海电音节的那两个夜晚 寿光科技学院的那几个二维码 金宝路上的那场雪 青岛方特的那几碗酒 下午六点的篮球场 东明到新庄的那两个人 还有meme米开朗的石头人，不败小小的狗头人，雄鹰联一把的死歌，武陵诸神的武器，zhi怕XB队友的狗熊征战过的召唤师峡谷。可惜不知道下次在一块征战是什么时候了。。。 每一个标签都是一段美好的回忆。我想一晚上我都讲不完，只是现在每一次回潍坊我都会去坐一次56路。。。 可能北门小摊已经关门了，可能校园广播还没放，可能图书馆坐满了，可能篮球场已经没场了，可能三号公寓已经不让我进了，但是在听到潍坊学院北门到了那一刹那后我还是会奋不顾身下车。。。 明天，你好。再见，昨天 大学的时候曾对不起一个女生，甚至连毕业的时候也没有好好和她说几句道别的话。。。 说不成熟不懂事都是借口，还是怪自己没有珍惜感情。当然在毕业后的几个月里，我在另一个她哪里也得到了刻骨铭心的伤痛。有时候一想或许这就是报应吧。。。 “长大”其实有时候也挺快的，对吧。 微风过，树微动。叶叶只为花相守愿只求，胭脂留。有你在左我在右说太多，没有用。有缘会长相守]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Memory</tag>
        <tag>College</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法相拥的人要好好道别]]></title>
    <url>%2Fbeginning.html</url>
    <content type="text"><![CDATA[种一棵树最好的时间是十年前，其次是现在。自己的第一篇日记就从这里开始吧。。。 总是要留下点什么 有时候也会想自己是要奔三的人了，回首发现好像也没剩下什么。 搭建这个博客的目的当然除了自己的矫情之外还有一些学习和工作上的总结，毕竟对于”忘”这个人体属性而言，我觉得他已经遍满了我人生中的各个角落。。。 前几篇文章我就想回顾一下自己大学以及大学后的生活把，发发牢骚。毕竟钢铁直男能憋出几个字来也是实属不易。 每个人都有他自己的节奏，你要按照自己的来 记得去年看过一篇文章《每个人都有自己节奏》其中有说道：随着年龄增长，有的人已经成家立业，甚至有了小孩，生活逐渐稳定下来，有的人毕业了还没有找到工作，有的人身处一段感情，却发现自己另有所爱。。。 上个月过年回家，和往常一样谈到了感情的事，看到父母逐渐变老的脸庞，有时候也会质疑自己是不是要稳定下来，多陪陪父母，该有一个家了。。。 有时候确实挺恨自己没出息，到了大部分人该有的年纪的时候却没有他们的该有的东西。但总归还是要面对现实，无论现在是顺境还是迷茫，要相信在命运给你安排的节奏里，一切都准时。。 主动点，温柔点，努力点 不知道是因为什么，做什么事情都没有像以前一样的兴趣和斗志。更加很少主动去和别人交流，或许是怕打扰别人把，甚至对于喜欢的人也是变得越来越主动疏远。这恐怕是自闭了。。。我要改！！！ 越来越发现自己的脾气好像确实没有以前好了，有时候会一点事就忍不住发火。然后过了一小会，就会很后悔。以前我可是脾气好的爆的人阿。我也不知道为什么会这样，可能是最近压力有点大加上休息不好吧，打算入夏的时候就多去运动运动，应该还有救。。 发现人确实不能一直再一个环境待太久，比如现在我的工作，虽然一周的工作量对于我来说一上午或许就能完成。但是剩余的时间却没有好好利用来扩展自己的知识领域，一想还是挺后悔的，希望今年能换份工作，无论 北京，上海，还是青岛。重要的是不要再愧对于自己把。。。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
</search>
